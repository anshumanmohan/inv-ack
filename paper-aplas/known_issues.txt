
1. The historical note was a little off once we took out the binary stuff. Should have discussed multiplication, division, exponentiation, logs rather than numerical position systems. 
	Leaving to Aquinas, or leaving until a discussion with Aquinas 

2. Need to sync up listings' line numbers with line numbers in code.
	On further thought, I think this is unnecessary. They already link to the code. Besides, the line numbers will be a bit off anyway because we have made unified listings out of code that is actually in different parts of the same file.

3. Notation of upper inverse is quite confusing with the -1 and the +. 
	How about just -1, or the subscript + replaced with an upward arrow?

4. See Anshuman's inline notes throughout. They mark rough language that was a little too delicate for him to massage away.

5. Test Makefile, slash remove it entirely and just give them a text-based order of compiling the files.

6. Acknowledge Charguéraud and Pottier's repeater when introducing repeater

7. Add a disclaimer that the practical hardcoded solution is obvious, we are trying to win in theory-land

8. I think A(m, n) should have a different notation than the diagonal A(n). 
	Proposed an example in Definition 1, which appears to be the last place it is used.

9. Shall we remove the pedantic sub_2 from Section 5.2?

10. What shall we do about overflowing listings? There are quite a few in the new format, especially towards the end.

11. From Skype:
	<<We show that our functions run in $O(n)$ for 
	inputs expressed in both unary and binary ($n$ = bitlength).>>
	Actually we didn't have any time complexity analysis for the inverse hyperoperations.
	The reader could figure out for themselves, but it's not explicitly stated in the paper.
	Aquinas, 5:38 PM
	Ok, let's just add a sentance or two somewhere.

12. I want to massage away the bold in Section 3.2.

13. Change Countdown Worker's and CW_Bin's budget argument to "b" everywhere (code and tex)

14. We can delete Lemma 16, it's a little irritating how obvious it is. Maybe the place that uses it can handle it with some careful writing?

15. Theorem 19: Instead of "a simple induction", say "induction on <blah>". When there is time, do this in all lemmas and theorems.

16. Widow on Page 4 that causes a bad code-based widow on Page 5. I am not fixing because Aquinas needs to add in the new table and the edited text that comes just after the table.

17. I have cut "The notation $\rf{f}{a}(b)$ does much better at separating 
the function, i.e. the repeater of $f$, and the variable $n$ than $f^{(n)}(a)$, 
while making clear that $a$ is a parameter of \emph{repeater} itself." from Hierarchy.tex, please add back if you want.

18. Base case and inductive case is somtimes listed with numbers and sometimes with dashes. Must make them consistent. Prefer dashes personally.

19. The two argument inv-ack needs a new notation, the subscript of 2 is too confusing. I have proposed something and piped it through.

20. It is confusing to refer to the 4th and 5th summands of (15), especially as they are typeset a little confusingly. I guess no need to change too urgently because this section needs cutting and reorganisation anyway.

21. Page 17, there is suddenly A(0,0). Is this a typo? Do you really meant the two-arg function again?





The comments below are from the reviewers:

22. A number of definitions omit the "\lambda n", e.g. def 3.1 and 3.5,
   it would be better imo to include it.

23. The key idea is about hyperoperations, a beautiful generalization of what the Ackermann function is trying to do, and IMO the "right way" to do it. Why don't you start with hyperoperations in the introduction?

24. Section 2: "Let us now consider hyperoperations more carefully" - we haven't really considered them so far, only seen some examples, so this was really confusing to me.

25. Base cases: These feel rather ad-hoc and arbitrary (they have to be a, 0, 1 for n = 0, 1, 2, but for n >= 3, it is not so clear. Can you give a more compelling argument for why these are the right choices?).

26: Don't cramp the three cases of the formal defn of hyperoperations into one line. It is too important.

27. Section 3.1, about inverses, I would like to see some kind of graph, to understand what is going on. Or/and perhaps an example of an inverse to start with before seeing the definition (to complement lines 183 and 184).

28. Theorem 3.1. (If F : N → N is increasing, then f is the upper inverse of F if and only if ∀n, m. f(n) ≤ m ⇐⇒ n ≤ F(m).) This is a Galois connection, perhaps you can say that in the text? (And maybe derive some more insights?)

29. Section 3.1 seems a strange collection of definitions/lemmas that are all quite different in nature. Add more structure?

30. Question I would like to see answered in the paper: The paper gives an alternative definition for div and log (than what's used in the standard library in Coq). Do proofs involving these functions become easier or harder in Coq? I would expect easier? Perhaps you could show an example?

31. p3, footnote 3, "change-of-base does not work on nat": This is obvious. Plus, it is not related to the 'nat' data structure, but on discrete logarithms in general: there is a confusion here between the mathematical object and its representation.

32. l.54 "defining division is unexpectedly painful". Is this really
  unexpected? Division and Euclid algorithm are indeed more involved,
  even on paper, than multiplication. Termination issues in Coq make
  the situation worse, but I am not sure about what you consider
  "unexpected" here.

33. 
	I think that the example and solution presented for defining
  	division is quite incomplete. For example, consider the following
  	Coq code, which depends only on Coq's standard prelude library:

	Definition edivn_rec d :=
	fix loop m q := match (m - d) with S m' => loop m' (S q) | _ => (q, m) end.

	Definition edivn m d := if Nat.ltb 0 d then edivn_rec (pred d) m 0 else (0, m).

	Here (edivn m d) computes a pair of nat, the quotient and remainder of
	the division of m by d. I can prove the expected comparison theorem in
	about 12 loc.

	My point is: I do think that the work presented in the paper has some
	value, but it should not be oversold. In my opinion, the authors
	should explain how and in which respect the technique presented helps,
	compared to case-by-case solutions like this one. It seems to me that
	the solutions listed l.63-75 are less relevant, and thus less
	informative.

34. 
	The fact that Coq's standard library does not include the definition
	of logarithm function is not a sufficient information I would
	say. What about other standard libraries? For instance, I am aware of
	a definition of logarithms in prime bases (which is arguably a
	special case, although one of specific interest):

	https://github.com/math-comp/math-comp/blob/9d8e99f50e1f00413c355277123a70e497491afc/mathcomp/ssreflect/prime.v#L15

	The same library mentions complexity issues about operations in unary
	nat (which explain in part the fact that only the case of prime bases
	is implemented for the unary representation provided by type nat):

	https://github.com/math-comp/math-comp/blob/9d8e99f50e1f00413c355277123a70e497491afc/mathcomp/ssreflect/prime.v#L48

The main idea to compute the inverse Ackermann function 
using what we have established so far is to use 
\Cref{thm: inv_ack_ack} to iteratively compute each 
level in the hierarchy starting from input $n+2$, 
then stop when the condition $\alpha_m(n+2) \le m + 3$ is met.

In order for this computation to run in linear time, 
we need to first make sure \textit{each} level 
$\alpha_m(n+2)$ is computed in linear time. 
We will then use a trick to achieve the linear 
time bound in the total computation using the relation
\begin{equation}
\alpha_m(n+2) = 1 + \alpha_m(\alpha_{m-1}(n+2)) \ \ \ \forall m\in \mathbb{N}_{>0}
\end{equation}

\subsection{Inverse Ackermann hierarchy in linear time}  \label{subsec: inv_ack_hier linear}

First note that, in the Gallina specification, all 
natural numbers are represented with a string of $\S$, 
the successor notation. All recursive functions in Gallina 
are required to decrease on one of its inputs, one or a 
few successors per recursive step. Thus all recursive 
functions, or Fixpoints in Gallina, must run in at least 
linear time over one of their inputs.

To compute the inverse Ackermann hierarchy for some input 
$n$ with a Gallina-complied function, we look at its 
generalization: Given a contraction $f$ over $\mathbb{N}$ 
and a Gallina function $\widetilde{f}$ computing $f$, 
we find a Gallina function $\widetilde{f^*}$ to compute 
its countdown, $f^*$.

\begin{defn} \label{defn: countdown rec helper}
Let $\mathcal{F}_k$ be the set of all Gallina functions 
$g: \mathbb{N}^k \to \mathbb{N}$. The 
\textit{countdown recursor helper} is an operator 
$\CRH : \mathcal{F}_1 \to \mathcal{F}_3$ such that for 
all $g\in \mathcal{F}_1$ and $n_0, n_1, c\in \mathbb{N}$:
\begin{equation}
\begin{aligned}
& \CRH\left(g\right)\left(n_0, n_1, c\right) = \\
& \begin{cases}
0 & \text{if } n_0 \le 1. \\
1 & \text{if } n_0 \ge 2, n_1 \le 1. \\
1 + \CRH \left(g\right)
		\left(n_0-1, g(n_1), n_1 - g(n_1) - 1\right)
		& \text{if } n_0\ge 2, n_1 \ge 2, c = 0. \\
\CRH \left(g\right)
			\left(n_0-1, n_1, c-1\right)
		& \text{if } n_0\ge 2, n_1\ge 2, c\ge 1.
\end{cases}
\end{aligned}
\end{equation}
\end{defn}

It is trivial to see that for all $g\in \mathcal{F}$, 
$\CRH(g)$ is a Gallina Fixpoint (a Gallina-complied 
recursive function) in $\mathcal{F}_3$ since its first 
input $n_0$ decreases by $1$ at every recursive step.

\begin{defn} \label{defn: countdown rec}
The \textit{countdown recursor} is an operator 
$\CR : \mathcal{F}_1 \to \mathcal{F}_1$ such that for 
all $g\in \mathcal{F}_1$ and $n\in \mathbb{N}$:
\begin{equation}
\CR(g)(n) = \CRH(g)(n, g(n), n - g(n) - 1)
\end{equation}
\end{defn}

Since it is built by a composition of a Gallina Fixpoint 
$\CRH$ and a Gallina function $g$, $\CR(g)$ is indeed a 
Gallina function in $\mathcal{F}_1$. We prove that $\CR$ 
is the equivalence of the countdown operation in Gallina 
for contractions:

\begin{lem} \label{lem: CRH_countdown}
Let $f: \mathbb{N}\to \mathbb{N}$ be a contraction. Suppose 
a function $\widetilde{f}\in \mathcal{F}_1$ computes $f$, 
then $\CR\left(\widetilde{f}\right)$ is a function in 
$\mathcal{F}_1$ computing $f^*$.
\end{lem}

\begin{proof}[Proof Sketch]
Let $g := \wt{f}$.
Firstly, from \Cref{defn: countdown rec helper}, we can prove 
that for all $n_0, n1, c, k\in \mathbb{N}$ such that $n_0\ge 2$ 
and $k\le \min\{n_0, c\}$:
\begin{equation*}
\CRH(g)\left(n_0, n_1, c\right) = \CRH(g)\left(n_0 - k, n_1, c - k\right)
\end{equation*}
This implies that if $n_0\ge c + 2$, then
\begin{equation*}
\CRH(g)\left(n_0, n_1, c\right) = 1 + \CRH(g)\left(n_0 - c - 1, g(n_1), n_1 - g(n_1) - 1\right)
\end{equation*}
If $n - 1\ge g(n) \ge 1$, let $n_0 := n$, $n_1 := g(n)$, $c := n - g(n) - 1$ gives:
\begin{equation*}
\begin{aligned}
& \CRH(g)\left(n, g(n), n - g(n) - 1\right) \\
& = 1 + \CRH(g)\left(g(n), g(g(n)), g(n) - g(g(n)) - 1\right)
\end{aligned}
\end{equation*}
Or
\begin{equation*}
\CR(g)(n) = 1 + \CR(g)(g(n))
\end{equation*}
Together with the initial values of $\CRH(g)$, we conclude 
that $\CRH(g)$, or $\CRH\left(\wt{f}\right)$ indeed computes $f^*$.

\end{proof}

With this lemma, we can define the equivalence of the inverse 
Ackermann hierarchy in Gallina:

\begin{defn}
The Gallina inverse Ackermann hierarchy is a sequence of 
functions $\wt{\alpha}_0, \wt{\alpha}_1, \ldots $ such 
that for all $m, n\in \mathbb{N}$:
\begin{equation}
\wt{\alpha}_m(n) = \begin{cases}
n - 2 & \text{if } m = 0 \\ \CR\left(\wt{\alpha}_{m-1}\right)(n) & \text{if } m \ge 1
\end{cases}
\end{equation}
Note that $x-y$ in Gallina is equivalent to $\max\{x-y, 0\}$ in practice.
\end{defn}

\Cref{lem: CRH_countdown} and \Cref{thm: inv_ack_countdown} 
trivially implies that $\wt{\alpha}_m$ is a Gallina 
computation of $\alpha_m$ for all $m\in \mathbb{N}$.

The important thing to come up with Gallina computations 
for the hierarchy is we want to compute them in linear 
time. We assert the hierarchy $\left\{\wt{\alpha}_m\right\}$ 
succeeds in doing so:

\begin{thm}  \label{thm: inv_ack_hier linear}
For each $m \in \mathbb{N}$, computing $\wt{\alpha}_m(n)$ 
takes at most $(m + o(1))n$ steps, where $n$ tends to infinity.
\end{thm}

\begin{proof}
TODO TODO TODO
\end{proof}

\subsection{Inverse Ackermann in linear time}  \label{subsec: inv_ack linear}

As mentioned, the task is to find the minimum $x$ for 
which $\alpha_x(n) \le x + 3$ for $n\ge 4$. It is tempting 
to go for a naive approach, after all the efficiencies 
we have developed so far: Starting from $x=0$, we 
iteratively compute $\alpha_x(n)$ and compare it with 
$x+3$. However, by our earlier analysis in 
\Cref{thm: inv_ack_hier linear}, the total amount of time needed is

$$ T(n) = \sum_{m = 0}^{\alpha(n)-1}(m + o(1))n = O\left(n\alpha(n)^2\right) $$

which is pretty efficient, given how slow-growing 
$\alpha(n)$ is. However, our ultimate goal is $O(n)$ time, 
thus we came up with a better approach. Interestingly, it 
is also based on \Cref{thm: inv_ack_hier linear}. 
Specifically, using \eqref{eq: countdown}, 
\Cref{thm: inv_ack_hier linear} implies we can actually 
compute $\alpha_m(n)$ in $O(\alpha_{m-1}(n))$ time, 
\textit{if} $\alpha_{m-1}(n)$ is given. It is thus 
beneficial if we retain the value of $\alpha_{m-1}(n)$ 
when computing $\alpha_m(n)$. The definition below is 
our Gallina recursor for this.

\begin{defn}  \label{defn: inv_ack_recursor_helper}
The inverse Ackermann recursor helper is a function 
$\IARH : \mathcal{F}_1\times \mathbb{N}^3 \to \mathbb{N}$ 
such that for all $g\in \mathcal{F}_1, n, c_0, c\in \mathbb{N}$, we have:
\begin{equation}
\begin{aligned}
& \IARH(g, n, c_0, c) =  \\
& \begin{cases}
c & \text{if } c = 1 \\
1 + \IARH\left(\CR(g), n, n - \CR(g)(n) - 1, c - 1\right) & \text{if } c \ge 1, c_0 = 0 \\
\IARH\left(g, n - 1, c_0 - 1, c - 1\right) & \text{if } c \ge 1, c_0 \ge 1
\end{cases}
\end{aligned}
\end{equation}
Note that $n - 1$ in Gallina means $\max\{n-1, 0\}$ here.
\end{defn}

\begin{defn}  \label{defn: inv_ack_recursor}
The inverse Ackermann recursor is a function 
$\IAR \in \mathcal{F}_1$ such that for all $n\in \mathbb{N}$, 
we have
\begin{equation}
\IAR(n) = \begin{cases}
0 & \text{if } n \le 1 \\ \IARH\left(\alpha_0, n + 2, 2, n\right) & \text{if } n\ge 2
\end{cases}
\end{equation}
\end{defn}

The following theorem is a central result in this paper, 
which asserts the correctness of $\IAR$.

\begin{thm} \label{thm: inv_ack_correct}
$\IAR$ is a Gallina function computing $\alpha(n)$.
\end{thm}

It is trivial to see that both $\IARH$ and $\IAR$ are 
Gallina functions. It suffices to show that 
$\IAR(n) = \alpha(n)$ for $n\ge 2$, since their values 
already match for $n\le 1$. Furthermore, if we trace 
the first two recursive steps in $\IARH$, we obtain
\begin{equation*}
\begin{aligned}
& \IARH(n+2, \alpha_0, 2, n) \\
& = 1 + \IARH(\alpha_1, n-2, n-\alpha_1(n)-1, n-3) \ \ \forall n\ge 2
\end{aligned}
\end{equation*}
It then suffices to show the following:

\begin{lem}  \label{lem: inv_ack_rec_helper}
For all $n\ge 2$,
$$\IARH(\alpha_1, n, n - \alpha_1(n) - 1, n - 3) = \min\left\{m : \alpha_m(n+2)\le m+3 \right\}$$.
\end{lem}

Before proving \Cref{lem: inv_ack_rec_helper}, we need an intermediate lemma.

\begin{lem}
For all $n\ge 2$
\end{lem}
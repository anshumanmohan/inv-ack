Require Import Omega.
Require Import prelims.
Require Import countdown_repeater.


(*
=============================================================================
**************** SECTION 4: COUNTDOWN COMPUTATIONS **************************
=============================================================================
*)

(* This section contains the actual definition of countdown, as we previously
   only work with its properties (i.e. what countdown should be, rather than
   what it actually is.
   I choose a different approach than my previous approach here, which is
   actually simpler (very straighforward), but will require a longer proof of
   correctness
   What happened to the previous approach? I am trying to clean its code to
   get rid of edge cases (e.g. check if (f n) is below 1 or not), not done yet
   Also, this new approach is both simpler and faster. It takes o(n) time instead
   of O(n) ! *)

(* ****** 1.1. DEFINITION *************************************)


(* Basically, repeats "f" "k" times or until we go below "a".
   Output "min(k, min{l : repeat f l n <= a})" *)
Fixpoint countdown_to_worker (a : nat) (f : nat -> nat) (n k : nat)
: nat :=
match k with
| 0    => 0
| S k' => match (n - a) with
          | 0   => 0
          | S _ => S (countdown_to_worker a f (f n) k') end
end.

(* Actual defintion. We give the worker a budget of "n" steps, which
   guarantees it reach below "a" before terminating *)
Definition countdown_to a f n := countdown_to_worker a f n n.


(* ****** 1.2. THEOREMS ************************************* *)

(* INITIAL VALUE THEOREM
   Basically countdown returns 0 if "n" is already below "a" *)
Theorem countdown_to_init : forall a f n k,
(n <= a) -> (countdown_to_worker a f n k = 0).
Proof.
intros a f n k Hna.
unfold countdown_to_worker.
destruct k. { trivial. }
replace (n - a) with 0 by omega.
trivial.
Qed.


(* INTERMEDIATE STATE LEMMA
   Similar to the general recursion formula for "countdown_to_recurse_rel" *)
Theorem countdown_to_intermediate : forall a f n k i,
contracting f
-> S i <= k
-> S a <= repeat f i n
-> countdown_to_worker a f n k
   = (S i) + countdown_to_worker a f (repeat f (S i) n) (k - (S i)).
Proof.
assert (forall a f n k, contracting f -> 1 <= k -> S a <= n
        -> countdown_to_worker a f n k
        = 1 + countdown_to_worker a f (f n) (k - 1)
        ) as case_0.
{ simpl. intros a f n k Hf Hk Ha.
  destruct k. { omega. }
  replace (S k - 1) with k by omega.
  unfold countdown_to_worker.
  replace (n-a) with (S(n - S a)) by omega.
  trivial.
}
intros a f n k i Hf Hik Hai.
induction i.
{ simpl. apply case_0; trivial. }
rewrite IHi.
- simpl. remember (f (repeat f i n)) as m.
  remember (k - S i) as l.
  replace (k - S(S i)) with (l - 1) by omega.
  rewrite case_0.
  + omega.
  + trivial.
  + omega.
  + simpl in Hai. rewrite Heqm. trivial.
- omega.
- apply (Nat.le_trans _ (repeat f (S i) n) _).
  + trivial.
  + apply Hf.
Qed.

Definition divc a b := countdown_to 0 (fun n => n - a) b.